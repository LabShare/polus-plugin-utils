import os, json, shutil, tempfile, string
import pytest
import filepattern
import numpy as np
from pathlib import Path
from bfio.bfio import BioReader, BioWriter

"""
This file is autogenerated from an ImageJ plugin generation pipeline. It is 
intended to test the accuracy of scaled ImageJ plugins.
"""

# Get plugin and test directories
plugin_dir = Path(__file__).parents[1]
test_dir = plugin_dir.joinpath('tests')

# Get src directory
src_path = plugin_dir.joinpath('src')

# Get main src file path
main_path = src_path.joinpath('main.py')

# Define file path to save test results
results_path = Path(__file__).with_name('scale_results.json')

# Instantiate list to store the results of each test case 
all_results = []


def rmse(full, tiled):
    MEAN = full.mean()
    RMSE = np.sqrt(((full-tiled)**2).mean())
    return RMSE, MEAN


def create_base_name(pattern):
    
    # Find the format locations of the file pattern
    flist = [k[1] for k in string.Formatter().parse(pattern) if k[1] is not None]
    
    # Instantiate the name
    name = pattern
    
    # Replace all format keys with '0'
    for k in flist:
        name = name.replace('{'+ k + '}', '0'*len(k))
    
    return name


def combine_images(img_dir, pattern):
    
    # Define a filepattern object for the image directory
    fp = filepattern.FilePattern(img_dir, pattern)
    
    # Set row and column variables
    r = 0
    c = 0
    
    # Instantiate dictionary to store images that belong in a row together
    row_images = {}

    # Iterate over each row in the image
    for row in fp(group_by='x'):
        
        # Iterate over each image in the row
        for f in row:
            
            # Get the current image's file name
            fname = f['file']
            print('Reading {} - position r:{} c:{}'.format(fname, r, c))
            
            # Read the image
            br = BioReader(f['file'], backend='python')
            img = br[:]
            
            # Begin the row if first image or add to row
            if c == 0:
                row_image = img
            else:
                row_image = np.hstack((row_image, img))

            # Close the reader
            br.close()
                
            # Increment the column index
            c += 1
        
        # Reset the column index after finishing the row
        c = 0
        
        print('The shape of the row is {}'.format(row_image.shape))
        
        # Add the row to the dictionary of rows
        row_images[r] = row_image
            
        # Increement the row index
        r += 1
    
    # Iterate over the row images and combine into single image
    for row, row_img in row_images.items():
        
        if row == 0:
            print('Adding row {} to the final image'.format(row))
            final_image = row_img
        
        else:
            print('Adding row {} to the final image'.format(row))
            final_image = np.vstack((final_image, row_img))

    
    final_shape = final_image.shape
    print('Shape of the final image is {}'.format(final_image.shape))
    print('Final image data type: {}'.format(final_image.dtype))
    
    return final_image


def write_image(img, out_dir):
    
    # Save the kernel
    with BioWriter(out_dir) as bw:
        # Update the save dimensions
        bw.X = img.shape[1]
        bw.Y = img.shape[0]
        bw.Z = 1
        bw.C = 1
        bw.T = 1
        # Update save data type
        bw.dtype = img.dtype
        # Save the kernel
        bw[:] = img
        # Close the writer
        bw.close()


def run_plugin(args, in_dir=None, out_dir=None):
    """
    Runs the plugin for given input arguemnts
    """
    
    # Check for user defined input/output directories
    if in_dir is not None:
        args['inpDir'] = in_dir
    
    if out_dir is not None:
        args['outDir'] = out_dir
    
    # Define the python os command
    command = 'python ' + str(main_path)
    
    # Add the arguments to the command
    for arg, value in args.items():
        if value is not None:
            command = command + ' --{} {}'.format(arg, value)
    
    # Run the plugin
    os.system(command)
        

def pytest_generate_tests(metafunc):
    
    # Create lists store test id's arguments and argument names
    idlist = []
    argnames = ['base', 'test']
    argvalues = []
    
    global base_dirs
    base_dirs = []
    
    # Get the list of test scenarios
    scenarios = metafunc.cls.scenarios
    
    # Iterate over each test scenario
    for s in scenarios:
        
        # Get the base case key for that scenario
        for key in s.keys():
            if key[0] in ['b', 'B']:
                base_key = key
        
        # Get the base case arguments dictionary
        base = s[base_key]
        
        # Define temp directories for each base case
        base_dir = Path(tempfile.mkdtemp(base['outDir']))
        base_input_dir = base_dir.joinpath('input')
        base_output_dir = base_dir.joinpath('output')
        
        # Create the input and output sub-directories
        base_input_dir.mkdir()
        base_output_dir.mkdir()
        
        # Define the base case file name
        base_name = Path(create_base_name(base['pattern']))
        
        # Add the base directory to list, so it can be cleaned up later
        base_dirs.append(base_dir)
        
        # Combine the base image tiles
        base_img = combine_images(img_dir = base['inpDir'], pattern=base['pattern'])
        
        # Write the base input image to temp file location
        write_image(img=base_img, out_dir=base_input_dir.joinpath(base_name))
        
        # Run the plugin for the base case
        run_plugin(
            base, 
            in_dir=base_input_dir, 
            out_dir=base_output_dir
            )
        
        # Organize the the arguments for each test in the scenario
        tests = [s[test_id] for test_id in s.keys() if test_id != base_key]
        scenario_ids = [test_id for test_id in s.keys() if test_id != base_key]
        
        # Iterate over each test for the scenario
        for test_id, test in zip(scenario_ids, tests):
            
            # Add the test arguments and test id
            idlist.append(test_id)
            argvalues.append([base_output_dir.joinpath(base_name), test])
    
    print('\n')
    print('argnames:', argnames)
    print('argvalues:', argvalues)
    print('idlist:', idlist)
    print('\n')
    
    metafunc.parametrize(argnames, argvalues, ids=idlist, scope="class")


class TestScaleAccuracy:
    
    # Get the input configuration file path
    config_file_path = Path(__file__).with_name('scale_test_config.json')

    # Load the config file to get test inputs
    with open(config_file_path) as fhand:
        scenarios = json.load(fhand)
        
    def test_accuracy(self, base, test, tmp_path, caplog):
        
        # Run the plugin for the test case
        run_plugin(args=test, out_dir=str(tmp_path))
        
        # Make a copy of the test arguments
        case_results = test.copy()
        
        # Combine the tiled output from the plugin
        tiled = combine_images(img_dir=tmp_path, pattern=test['pattern'])
        
        # Read the base case image
        with BioReader(base) as br:
            full = br[:]
            br.close()
        
        # Calcualte the RMSE and get the mean of the full image
        RMSE, MEAN = rmse(full=full, tiled=tiled)
        
        # Add the rmse, percent-rmse and mean to the results
        case_results['mean'] = MEAN
        case_results['rmse'] = RMSE
        case_results['prmse'] = RMSE/MEAN
        
        # Add the results to all results
        all_results.append(case_results)
        
        print('RMSE:', RMSE)
        print('mean', MEAN)   
        

# Clean up routine to run at end of testing session
@pytest.fixture(scope='session', autouse=True)
def cleanup(request):
    
    # Write the final results
    def write_results():
        print(all_results)
        results_json = json.dumps(all_results, indent=4)
        with open(results_path, 'w') as fhand:
            fhand.write(results_json)
            fhand.close()
    
    # Delete the base-case temp directories
    def remove_files():
        for base_dir in base_dirs:
            print(os.listdir(base_dir))
            print('cleaning up {}'.format(base_dir))
            shutil.rmtree(base_dir)    
    
    request.addfinalizer(write_results)
    request.addfinalizer(remove_files)
    